import {
  $extend,
  $if,
  clone,
  createMessage,
  createSection,
  defaultIcon,
  disables,
  eachSection,
  findSection,
  isDOM,
  isPlaceholder,
  localize,
  undefine,
  whenAvailable,
  wrapper
} from "./chunk-35D2SQIE.js";
import "./chunk-OZI5HTJH.js";

// node_modules/@formkit/addons/node_modules/@formkit/auto-animate/index.mjs
var parents = /* @__PURE__ */ new Set();
var coords = /* @__PURE__ */ new WeakMap();
var siblings = /* @__PURE__ */ new WeakMap();
var animations = /* @__PURE__ */ new WeakMap();
var intersections = /* @__PURE__ */ new WeakMap();
var intervals = /* @__PURE__ */ new WeakMap();
var options = /* @__PURE__ */ new WeakMap();
var debounces = /* @__PURE__ */ new WeakMap();
var enabled = /* @__PURE__ */ new WeakSet();
var root;
var scrollX = 0;
var scrollY = 0;
var TGT = "__aa_tgt";
var DEL = "__aa_del";
var NEW = "__aa_new";
var handleMutations = (mutations2) => {
  const elements = getElements(mutations2);
  if (elements) {
    elements.forEach((el) => animate(el));
  }
};
var handleResizes = (entries) => {
  entries.forEach((entry) => {
    if (entry.target === root)
      updateAllPos();
    if (coords.has(entry.target))
      updatePos(entry.target);
  });
};
function observePosition(el) {
  const oldObserver = intersections.get(el);
  oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();
  let rect = coords.get(el);
  let invocations = 0;
  const buffer = 5;
  if (!rect) {
    rect = getCoords(el);
    coords.set(el, rect);
  }
  const { offsetWidth, offsetHeight } = root;
  const rootMargins = [
    rect.top - buffer,
    offsetWidth - (rect.left + buffer + rect.width),
    offsetHeight - (rect.top + buffer + rect.height),
    rect.left - buffer
  ];
  const rootMargin = rootMargins.map((px) => `${-1 * Math.floor(px)}px`).join(" ");
  const observer2 = new IntersectionObserver(() => {
    ++invocations > 1 && updatePos(el);
  }, {
    root,
    threshold: 1,
    rootMargin
  });
  observer2.observe(el);
  intersections.set(el, observer2);
}
function updatePos(el) {
  clearTimeout(debounces.get(el));
  const optionsOrPlugin = getOptions(el);
  const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;
  debounces.set(el, setTimeout(async () => {
    const currentAnimation = animations.get(el);
    try {
      await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);
      coords.set(el, getCoords(el));
      observePosition(el);
    } catch {
    }
  }, delay));
}
function updateAllPos() {
  clearTimeout(debounces.get(root));
  debounces.set(root, setTimeout(() => {
    parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));
  }, 100));
}
function poll(el) {
  setTimeout(() => {
    intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2e3));
  }, Math.round(2e3 * Math.random()));
}
function lowPriority(callback) {
  if (typeof requestIdleCallback === "function") {
    requestIdleCallback(() => callback());
  } else {
    requestAnimationFrame(() => callback());
  }
}
var mutations;
var resize;
if (typeof window !== "undefined") {
  root = document.documentElement;
  mutations = new MutationObserver(handleMutations);
  resize = new ResizeObserver(handleResizes);
  window.addEventListener("scroll", () => {
    scrollY = window.scrollY;
    scrollX = window.scrollX;
  });
  resize.observe(root);
}
function getElements(mutations2) {
  const observedNodes = mutations2.reduce((nodes, mutation) => {
    return [
      ...nodes,
      ...Array.from(mutation.addedNodes),
      ...Array.from(mutation.removedNodes)
    ];
  }, []);
  const onlyCommentNodesObserved = observedNodes.every((node) => node.nodeName === "#comment");
  if (onlyCommentNodesObserved)
    return false;
  return mutations2.reduce((elements, mutation) => {
    if (elements === false)
      return false;
    if (mutation.target instanceof Element) {
      target(mutation.target);
      if (!elements.has(mutation.target)) {
        elements.add(mutation.target);
        for (let i = 0; i < mutation.target.children.length; i++) {
          const child = mutation.target.children.item(i);
          if (!child)
            continue;
          if (DEL in child) {
            return false;
          }
          target(mutation.target, child);
          elements.add(child);
        }
      }
      if (mutation.removedNodes.length) {
        for (let i = 0; i < mutation.removedNodes.length; i++) {
          const child = mutation.removedNodes[i];
          if (DEL in child) {
            return false;
          }
          if (child instanceof Element) {
            elements.add(child);
            target(mutation.target, child);
            siblings.set(child, [
              mutation.previousSibling,
              mutation.nextSibling
            ]);
          }
        }
      }
    }
    return elements;
  }, /* @__PURE__ */ new Set());
}
function target(el, child) {
  if (!child && !(TGT in el))
    Object.defineProperty(el, TGT, { value: el });
  else if (child && !(TGT in child))
    Object.defineProperty(child, TGT, { value: el });
}
function animate(el) {
  var _a;
  const isMounted = el.isConnected;
  const preExisting = coords.has(el);
  if (isMounted && siblings.has(el))
    siblings.delete(el);
  if (animations.has(el)) {
    (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();
  }
  if (NEW in el) {
    add(el);
  } else if (preExisting && isMounted) {
    remain(el);
  } else if (preExisting && !isMounted) {
    remove(el);
  } else {
    add(el);
  }
}
function raw(str) {
  return Number(str.replace(/[^0-9.\-]/g, ""));
}
function getScrollOffset(el) {
  let p = el.parentElement;
  while (p) {
    if (p.scrollLeft || p.scrollTop) {
      return { x: p.scrollLeft, y: p.scrollTop };
    }
    p = p.parentElement;
  }
  return { x: 0, y: 0 };
}
function getCoords(el) {
  const rect = el.getBoundingClientRect();
  const { x, y } = getScrollOffset(el);
  return {
    top: rect.top + y,
    left: rect.left + x,
    width: rect.width,
    height: rect.height
  };
}
function getTransitionSizes(el, oldCoords, newCoords) {
  let widthFrom = oldCoords.width;
  let heightFrom = oldCoords.height;
  let widthTo = newCoords.width;
  let heightTo = newCoords.height;
  const styles = getComputedStyle(el);
  const sizing = styles.getPropertyValue("box-sizing");
  if (sizing === "content-box") {
    const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);
    const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);
    widthFrom -= paddingX;
    widthTo -= paddingX;
    heightFrom -= paddingY;
    heightTo -= paddingY;
  }
  return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);
}
function getOptions(el) {
  return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : { duration: 250, easing: "ease-in-out" };
}
function getTarget(el) {
  if (TGT in el)
    return el[TGT];
  return void 0;
}
function isEnabled(el) {
  const target2 = getTarget(el);
  return target2 ? enabled.has(target2) : false;
}
function forEach(parent, ...callbacks) {
  callbacks.forEach((callback) => callback(parent, options.has(parent)));
  for (let i = 0; i < parent.children.length; i++) {
    const child = parent.children.item(i);
    if (child) {
      callbacks.forEach((callback) => callback(child, options.has(child)));
    }
  }
}
function getPluginTuple(pluginReturn) {
  if (Array.isArray(pluginReturn))
    return pluginReturn;
  return [pluginReturn];
}
function isPlugin(config) {
  return typeof config === "function";
}
function remain(el) {
  const oldCoords = coords.get(el);
  const newCoords = getCoords(el);
  if (!isEnabled(el))
    return coords.set(el, newCoords);
  let animation;
  if (!oldCoords)
    return;
  const pluginOrOptions = getOptions(el);
  if (typeof pluginOrOptions !== "function") {
    const deltaX = oldCoords.left - newCoords.left;
    const deltaY = oldCoords.top - newCoords.top;
    const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);
    const start = {
      transform: `translate(${deltaX}px, ${deltaY}px)`
    };
    const end = {
      transform: `translate(0, 0)`
    };
    if (widthFrom !== widthTo) {
      start.width = `${widthFrom}px`;
      end.width = `${widthTo}px`;
    }
    if (heightFrom !== heightTo) {
      start.height = `${heightFrom}px`;
      end.height = `${heightTo}px`;
    }
    animation = el.animate([start, end], {
      duration: pluginOrOptions.duration,
      easing: pluginOrOptions.easing
    });
  } else {
    const [keyframes] = getPluginTuple(pluginOrOptions(el, "remain", oldCoords, newCoords));
    animation = new Animation(keyframes);
    animation.play();
  }
  animations.set(el, animation);
  coords.set(el, newCoords);
  animation.addEventListener("finish", updatePos.bind(null, el));
}
function add(el) {
  if (NEW in el)
    delete el[NEW];
  const newCoords = getCoords(el);
  coords.set(el, newCoords);
  const pluginOrOptions = getOptions(el);
  if (!isEnabled(el))
    return;
  let animation;
  if (typeof pluginOrOptions !== "function") {
    animation = el.animate([
      { transform: "scale(.98)", opacity: 0 },
      { transform: "scale(0.98)", opacity: 0, offset: 0.5 },
      { transform: "scale(1)", opacity: 1 }
    ], {
      duration: pluginOrOptions.duration * 1.5,
      easing: "ease-in"
    });
  } else {
    const [keyframes] = getPluginTuple(pluginOrOptions(el, "add", newCoords));
    animation = new Animation(keyframes);
    animation.play();
  }
  animations.set(el, animation);
  animation.addEventListener("finish", updatePos.bind(null, el));
}
function cleanUp(el, styles) {
  var _a;
  el.remove();
  coords.delete(el);
  siblings.delete(el);
  animations.delete(el);
  (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();
  setTimeout(() => {
    if (DEL in el)
      delete el[DEL];
    Object.defineProperty(el, NEW, { value: true, configurable: true });
    if (styles && el instanceof HTMLElement) {
      for (const style in styles) {
        el.style[style] = "";
      }
    }
  }, 0);
}
function remove(el) {
  var _a;
  if (!siblings.has(el) || !coords.has(el))
    return;
  const [prev, next] = siblings.get(el);
  Object.defineProperty(el, DEL, { value: true, configurable: true });
  const finalX = window.scrollX;
  const finalY = window.scrollY;
  if (next && next.parentNode && next.parentNode instanceof Element) {
    next.parentNode.insertBefore(el, next);
  } else if (prev && prev.parentNode) {
    prev.parentNode.appendChild(el);
  } else {
    (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);
  }
  if (!isEnabled(el))
    return cleanUp(el);
  const [top, left, width, height] = deletePosition(el);
  const optionsOrPlugin = getOptions(el);
  const oldCoords = coords.get(el);
  if (finalX !== scrollX || finalY !== scrollY) {
    adjustScroll(el, finalX, finalY, optionsOrPlugin);
  }
  let animation;
  let styleReset = {
    position: "absolute",
    top: `${top}px`,
    left: `${left}px`,
    width: `${width}px`,
    height: `${height}px`,
    margin: "0",
    pointerEvents: "none",
    transformOrigin: "center",
    zIndex: "100"
  };
  if (!isPlugin(optionsOrPlugin)) {
    Object.assign(el.style, styleReset);
    animation = el.animate([
      {
        transform: "scale(1)",
        opacity: 1
      },
      {
        transform: "scale(.98)",
        opacity: 0
      }
    ], { duration: optionsOrPlugin.duration, easing: "ease-out" });
  } else {
    const [keyframes, options2] = getPluginTuple(optionsOrPlugin(el, "remove", oldCoords));
    if ((options2 === null || options2 === void 0 ? void 0 : options2.styleReset) !== false) {
      styleReset = (options2 === null || options2 === void 0 ? void 0 : options2.styleReset) || styleReset;
      Object.assign(el.style, styleReset);
    }
    animation = new Animation(keyframes);
    animation.play();
  }
  animations.set(el, animation);
  animation.addEventListener("finish", cleanUp.bind(null, el, styleReset));
}
function adjustScroll(el, finalX, finalY, optionsOrPlugin) {
  const scrollDeltaX = scrollX - finalX;
  const scrollDeltaY = scrollY - finalY;
  const scrollBefore = document.documentElement.style.scrollBehavior;
  const scrollBehavior = getComputedStyle(root).scrollBehavior;
  if (scrollBehavior === "smooth") {
    document.documentElement.style.scrollBehavior = "auto";
  }
  window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);
  if (!el.parentElement)
    return;
  const parent = el.parentElement;
  let lastHeight = parent.clientHeight;
  let lastWidth = parent.clientWidth;
  const startScroll = performance.now();
  function smoothScroll() {
    requestAnimationFrame(() => {
      if (!isPlugin(optionsOrPlugin)) {
        const deltaY = lastHeight - parent.clientHeight;
        const deltaX = lastWidth - parent.clientWidth;
        if (startScroll + optionsOrPlugin.duration > performance.now()) {
          window.scrollTo({
            left: window.scrollX - deltaX,
            top: window.scrollY - deltaY
          });
          lastHeight = parent.clientHeight;
          lastWidth = parent.clientWidth;
          smoothScroll();
        } else {
          document.documentElement.style.scrollBehavior = scrollBefore;
        }
      }
    });
  }
  smoothScroll();
}
function deletePosition(el) {
  const oldCoords = coords.get(el);
  const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));
  let offsetParent = el.parentElement;
  while (offsetParent && (getComputedStyle(offsetParent).position === "static" || offsetParent instanceof HTMLBodyElement)) {
    offsetParent = offsetParent.parentElement;
  }
  if (!offsetParent)
    offsetParent = document.body;
  const parentStyles = getComputedStyle(offsetParent);
  const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);
  const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);
  const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);
  return [top, left, width, height];
}
function autoAnimate(el, config = {}) {
  if (mutations && resize) {
    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
    const isDisabledDueToReduceMotion = mediaQuery.matches && !isPlugin(config) && !config.disrespectUserMotionPreference;
    if (!isDisabledDueToReduceMotion) {
      enabled.add(el);
      if (getComputedStyle(el).position === "static") {
        Object.assign(el.style, { position: "relative" });
      }
      forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));
      if (isPlugin(config)) {
        options.set(el, config);
      } else {
        options.set(el, { duration: 250, easing: "ease-in-out", ...config });
      }
      mutations.observe(el, { childList: true });
      parents.add(el);
    }
  }
  return Object.freeze({
    parent: el,
    enable: () => {
      enabled.add(el);
    },
    disable: () => {
      enabled.delete(el);
    },
    isEnabled: () => enabled.has(el)
  });
}

// node_modules/@formkit/addons/dist/index.mjs
var pendingIds = /* @__PURE__ */ new Map();
var optionOverrides = /* @__PURE__ */ new Map();
var autoAnimateOptionsId = 0;
var observer = null;
var observerTimeout = 0;
function createObserver() {
  observeIds();
  observer = new MutationObserver(() => {
    observeIds();
    if (!pendingIds.size && observer) {
      observer.disconnect();
      observer = null;
    }
  });
  observer.observe(document, { childList: true, subtree: true });
}
function observeIds() {
  pendingIds.forEach((options2, id) => {
    const outer = document.getElementById(id);
    if (outer) {
      clearTimeout(observerTimeout);
      pendingIds.delete(id);
      observerTimeout = setTimeout(() => {
        const targets = document.querySelectorAll("[data-auto-animate]");
        targets.forEach((target2) => {
          let overrideOptions;
          const optionsId = target2.getAttribute("data-auto-animate");
          if (optionsId) {
            overrideOptions = optionOverrides.get(optionsId);
          }
          autoAnimate(target2, overrideOptions || options2 || {});
        });
      }, 250);
    }
  });
}
function createAutoAnimatePlugin(options2, animationTargets = {
  global: ["outer", "inner"],
  form: ["form"],
  repeater: ["items"]
}) {
  return (node) => {
    node.on("created", () => {
      var _a;
      if (typeof ((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.schema) === "function") {
        if (typeof window === void 0)
          return;
        const originalSchema = node.props.definition.schema;
        node.props.definition.schema = (extensions) => {
          const schema = originalSchema(extensions);
          const finalSchema = Array.isArray(schema) ? schema[0] : schema;
          eachSection(finalSchema, (section) => {
            var _a2, _b;
            if (isDOM(section)) {
              let isAnimationTarget = false;
              const sectionName = (_a2 = section === null || section === void 0 ? void 0 : section.meta) === null || _a2 === void 0 ? void 0 : _a2.section;
              let instanceId = true;
              if ((_b = section === null || section === void 0 ? void 0 : section.meta) === null || _b === void 0 ? void 0 : _b.autoAnimate) {
                isAnimationTarget = true;
                if (typeof section.meta.autoAnimate === "object") {
                  const newOptions = Object.assign({}, options2, section.meta.autoAnimate);
                  instanceId = `${node.props.id}-${autoAnimateOptionsId++}`;
                  optionOverrides.set(instanceId, newOptions);
                }
              }
              if (!isAnimationTarget && sectionName && typeof sectionName === "string") {
                if (animationTargets.global.includes(sectionName) || animationTargets[node.props.type] && animationTargets[node.props.type].includes(sectionName)) {
                  isAnimationTarget = true;
                }
              }
              if (!isAnimationTarget)
                return;
              if (!(section === null || section === void 0 ? void 0 : section.attrs)) {
                section.attrs = { "data-auto-animate": instanceId };
              } else {
                Object.assign(section.attrs, {
                  "data-auto-animate": instanceId
                });
              }
              if (node.props.id) {
                pendingIds.set(node.props.id, options2);
              }
            }
          });
          return finalSchema;
        };
      }
      if (!observer && typeof window !== "undefined")
        createObserver();
    });
  };
}
var badge = createSection("badge", () => ({
  $el: "span",
  attrs: {
    role: "presentation"
  }
}));
var stepActions = createSection("stepActions", () => ({
  $el: "div"
}));
var stepInner = createSection("stepInner", "div");
var stepNext = createSection("stepNext", () => ({
  $el: "div",
  if: "$isLastStep === false || $stepIndex === 0",
  children: [
    {
      $cmp: "FormKit",
      bind: "$nextAttrs",
      props: {
        type: "button",
        label: {
          if: "$nextLabel",
          then: "$nextLabel",
          else: "$ui.next.value"
        },
        "data-next": "$isLastStep === false",
        onClick: "$handlers.next"
      }
    }
  ]
}));
var stepOuter = createSection("stepOuter", () => ({
  $el: "div",
  attrs: {
    key: "$id",
    "data-type": "step",
    "data-disabled": "$disabled || undefined",
    "data-complete": "$state.complete || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined",
    id: "$id",
    role: "tabpanel",
    "aria-labelledby": '$node.parent.props.id + "_tab_" + $stepIndex',
    class: "$classes.step",
    hidden: "$isActiveStep === false || undefined"
  }
}));
var stepPrevious = createSection("stepPrevious", () => ({
  $el: "div",
  if: "$isFirstStep === false",
  children: [
    {
      $cmp: "FormKit",
      bind: "$previousAttrs",
      props: {
        type: "button",
        label: {
          if: "$previousLabel",
          then: "$previousLabel",
          else: "$ui.prev.value"
        },
        "data-prev": "$isFirstStep === false",
        onClick: "$handlers.previous"
      }
    }
  ]
}));
var steps = createSection("steps", () => ({
  $el: "div"
}));
var stepIcon = (sectionKey, el) => {
  return createSection(`${sectionKey}Icon`, () => {
    const rawIconProp = `_raw${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}Icon`;
    return {
      if: `$step.${sectionKey}Icon && $step.${rawIconProp}`,
      then: {
        $el: `${el ? el : "span"}`,
        attrs: {
          class: `$classes.${sectionKey}Icon + " formkit-icon"`,
          innerHTML: `$step.${rawIconProp}`,
          role: "presentation",
          onClick: `$handlers.iconClick(${sectionKey})`
        }
      },
      else: {
        if: `$${sectionKey}Icon && $${rawIconProp}`,
        then: {
          $el: `${el ? el : "span"}`,
          attrs: {
            class: `$classes.${sectionKey}Icon + " formkit-icon"`,
            innerHTML: `$${rawIconProp}`,
            role: "presentation",
            onClick: `$handlers.iconClick(${sectionKey})`
          }
        }
      }
    };
  })();
};
var tab = createSection("tab", () => ({
  $el: "button",
  for: ["step", "index", "$steps"],
  attrs: {
    key: "$step.id",
    type: "button",
    onClick: "$step.makeActive",
    "data-active": "$step.isActiveStep",
    "data-valid": "$step.isValid",
    "data-visited": "$step.hasBeenVisited",
    role: "tab",
    id: '$id + "_tab_" + $index',
    "aria-selected": "$step.isActiveStep || false",
    "aria-controls": "$step.id",
    tabindex: {
      if: "$step.isActiveStep",
      then: "0",
      else: "-1"
    }
  }
}));
var tabLabel = createSection("tabLabel", () => ({
  $el: "span"
}));
var tabs = createSection("tabs", () => ({
  $el: "div",
  attrs: {
    role: "tablist"
  }
}));
var multiStepOuter = createSection("multiStepOuter", () => ({
  $el: "div",
  attrs: {
    key: "$id",
    id: "$id",
    class: "$classes.outer",
    "data-family": "$family || undefined",
    "data-type": "$type",
    "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
    "data-disabled": "$disabled || undefined",
    "data-complete": "$state.complete || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined"
  }
}));
var multiStep = {
  /**
   * The actual schema of the input, or a function that returns the schema.
   */
  schema: multiStepOuter($extend(wrapper(tabs(tab($if('$tabStyle === "tab" || ($tabStyle === "progress" && $hideProgressLabels === false)', tabLabel("$step.stepName")), $if("($step.totalErrorCount > 0) && $step.showStepErrors", badge("$step.totalErrorCount")), $if("$step.isValid && $step.hasBeenVisited", badge(stepIcon("validStep"))))), steps("$slots.default")), {
    attrs: {
      "data-tab-style": "$tabStyle",
      "data-hide-labels": "$hideProgressLabels"
    }
  })),
  /**
   * The type of node, can be a list, group, or input.
   */
  type: "group",
  /**
   * The family of inputs this one belongs too. For example "text" and "email"
   * are both part of the "text" family. This is primary used for styling.
   */
  family: "multi-step",
  /**
   * An array of extra props to accept for this input.
   */
  props: [
    "allowIncomplete",
    "hideProgressLabels",
    "tabStyle",
    "beforeStepChange",
    "validStepIcon"
  ],
  /**
   * Additional features that should be added to your input
   */
  features: [defaultIcon("validStep", "check"), disables]
};
var step = {
  /**
   * The actual schema of the input, or a function that returns the schema.
   */
  schema: stepOuter(stepInner("$slots.default"), stepActions(stepPrevious(), stepNext())),
  /**
   * The type of node, can be a list, group, or input.
   */
  type: "group",
  /**
   * The family of inputs this one belongs too. For example "text" and "email"
   * are both part of the "text" family. This is primary used for styling.
   */
  family: "",
  /**
   * An array of extra props to accept for this input.
   */
  props: [
    "previousLabel",
    "nextLabel",
    "beforeStepChange",
    "previousAttrs",
    "nextAttrs",
    "validStepIcon"
  ],
  /**
   * Additional features that should be added to your input
   */
  features: [localize("next"), localize("prev"), disables]
};
var isBrowser = typeof window !== "undefined";
var camel2title = (str) => {
  if (!str)
    return str;
  return str.replace(/([A-Z])/g, (match) => ` ${match}`).replace(/^./, (match) => match.toUpperCase()).trim();
};
function orderSteps(steps2) {
  if (!isBrowser || !steps2)
    return steps2;
  const orderedSteps = [...steps2];
  orderedSteps.sort((a, b) => {
    const aEl = document.getElementById(a.id);
    const bEl = document.getElementById(b.id);
    if (!aEl || !bEl)
      return 0;
    return aEl.compareDocumentPosition(bEl) === 2 ? 1 : -1;
  });
  orderedSteps.map((step2) => {
    step2.ordered = true;
  });
  return orderedSteps;
}
function setNodePositionProps(steps2) {
  if (!steps2)
    return;
  steps2.forEach((step2, index) => {
    step2.isFirstStep = index === 0;
    step2.isLastStep = index === steps2.length - 1;
    step2.stepIndex = index;
    step2.steps = steps2;
  });
}
function showStepErrors(step2) {
  if (!step2.showStepErrors)
    return;
  return parseInt(step2.blockingCount) + parseInt(step2.errorCount) > 0;
}
async function isTargetStepAllowed(currentStep, targetStep) {
  var _a, _b, _c;
  if (currentStep === targetStep)
    return true;
  const { allowIncomplete } = ((_a = currentStep.node.parent) === null || _a === void 0 ? void 0 : _a.props) || {};
  const parentNode = currentStep.node.parent;
  const currentStepIndex = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps.indexOf(currentStep);
  const targetStepIndex = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps.indexOf(targetStep);
  const beforeStepChange = currentStep.node.props.beforeStepChange || ((_b = currentStep.node.parent) === null || _b === void 0 ? void 0 : _b.props.beforeStepChange);
  if (beforeStepChange && typeof beforeStepChange === "function") {
    if (parentNode) {
      parentNode === null || parentNode === void 0 ? void 0 : parentNode.store.set(createMessage({
        key: "loading",
        value: true,
        visible: false
      }));
      parentNode.props.disabled = true;
      currentStep.disabled = true;
    }
    const result = await beforeStepChange({
      currentStep,
      targetStep,
      delta: targetStepIndex - currentStepIndex
    });
    if (parentNode) {
      parentNode === null || parentNode === void 0 ? void 0 : parentNode.store.remove("loading");
      parentNode.props.disabled = false;
      currentStep.disabled = false;
    }
    if (typeof result === "boolean" && !result)
      return false;
  }
  triggerStepValidations(currentStep);
  currentStep.showStepErrors = true;
  if (targetStepIndex < currentStepIndex) {
    return true;
  }
  const delta = targetStepIndex - currentStepIndex;
  for (let i = 0; i < delta; i++) {
    const intermediateStep = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps[currentStepIndex + i];
    const stepIsAllowed = allowIncomplete || ((_c = intermediateStep.state) === null || _c === void 0 ? void 0 : _c.valid);
    if (!stepIsAllowed) {
      return false;
    }
  }
  return true;
}
async function setActiveStep(targetStep, e) {
  if (e) {
    e.preventDefault();
  }
  if (targetStep && targetStep.node.name && targetStep.node.parent) {
    const currentStep = targetStep.node.parent.props.steps.find((step2) => {
      var _a;
      return step2.node.name === ((_a = targetStep.node.parent) === null || _a === void 0 ? void 0 : _a.props.activeStep);
    });
    const stepIsAllowed = await isTargetStepAllowed(currentStep, targetStep);
    if (stepIsAllowed && targetStep.node.parent.context) {
      targetStep.node.parent.props.activeStep = targetStep.node.name;
    }
  }
}
async function incrementStep(delta, currentStep) {
  if (currentStep && currentStep.node.name && currentStep.node.parent) {
    const steps2 = currentStep.node.parent.props.steps;
    const stepIndex = currentStep.stepIndex;
    const targetStep = steps2[stepIndex + delta];
    if (!targetStep)
      return;
    const stepIsAllowed = await isTargetStepAllowed(currentStep, targetStep);
    if (targetStep && stepIsAllowed) {
      currentStep.node.parent.props.activeStep = targetStep.node.name;
    }
  }
}
function triggerStepValidations(step2) {
  var _a, _b;
  step2.node.walk((n) => {
    n.store.set(createMessage({
      key: "submitted",
      value: true,
      visible: false
    }));
  });
  return ((_a = step2.node.context) === null || _a === void 0 ? void 0 : _a.state.valid) || ((_b = step2.node.parent) === null || _b === void 0 ? void 0 : _b.props.allowIncomplete);
}
function initEvents(node, el) {
  if (!(el instanceof HTMLElement))
    return;
  el.addEventListener("keydown", (event) => {
    var _a;
    if (event.target instanceof HTMLButtonElement) {
      if (event.key === "Tab" && "data-next" in ((_a = event.target) === null || _a === void 0 ? void 0 : _a.attributes) && !event.shiftKey) {
        event.preventDefault();
        const activeStepContext = node.children.find((step2) => !isPlaceholder(step2) && step2.name === node.props.activeStep);
        if (activeStepContext && activeStepContext.context) {
          incrementStep(1, activeStepContext.context);
        }
      }
    }
  });
}
function createSSRStepsFromTabs(tabs2) {
  if (!tabs2 || !tabs2.length)
    return [];
  const placeholderTabs = tabs2.map((tab2, index) => {
    return {
      __isPlaceholder: true,
      stepName: tab2.props.label || camel2title(tab2.props.name),
      isFirstStep: index === 0,
      isLastStep: index === tabs2.length - 1,
      isActiveStep: index === 0,
      node: {
        name: tab2.props.name
      }
    };
  });
  return placeholderTabs;
}
function createMultiStepPlugin(options2) {
  let isFirstStep = true;
  const multiStepPlugin = (node) => {
    var _a, _b;
    if (node.props.type === "multi-step") {
      if (!node.context)
        return;
      isFirstStep = true;
      node.addProps(["steps", "tabs", "activeStep"]);
      if (node.context.slots && node.context.slots.default) {
        node.props.tabs = node.context.slots.default();
      }
      node.props.steps = node.props.steps || createSSRStepsFromTabs(node.props.tabs);
      node.props.allowIncomplete = typeof node.props.allowIncomplete === "boolean" ? node.props.allowIncomplete : typeof (options2 === null || options2 === void 0 ? void 0 : options2.allowIncomplete) === "boolean" ? options2 === null || options2 === void 0 ? void 0 : options2.allowIncomplete : true;
      node.props.hideProgressLabels = typeof node.props.hideProgressLabels === "boolean" ? node.props.hideProgressLabels : (options2 === null || options2 === void 0 ? void 0 : options2.hideProgressLabels) || false;
      node.props.tabStyle = node.props.tabStyle || (options2 === null || options2 === void 0 ? void 0 : options2.tabStyle) || "tab";
      node.context.handlers.triggerStepValidations = triggerStepValidations;
      node.context.handlers.showStepErrors = showStepErrors;
      node.on("created", () => {
        if (!node.context)
          return;
        node.extend("next", {
          get: (node2) => () => {
            var _a2;
            incrementStep(1, (_a2 = node2 === null || node2 === void 0 ? void 0 : node2.props) === null || _a2 === void 0 ? void 0 : _a2.steps.find((step2) => step2.isActiveStep));
          },
          set: false
        });
        node.extend("previous", {
          get: (node2) => () => {
            var _a2;
            incrementStep(-1, (_a2 = node2 === null || node2 === void 0 ? void 0 : node2.props) === null || _a2 === void 0 ? void 0 : _a2.steps.find((step2) => step2.isActiveStep));
          },
          set: false
        });
        node.extend("goTo", {
          get: (node2) => (target2) => {
            if (typeof target2 === "number") {
              const targetStep = node2.props.steps[target2];
              setActiveStep(targetStep);
            } else if (typeof target2 === "string") {
              const targetStep = node2.props.steps.find((step2) => step2.node.name === target2);
              setActiveStep(targetStep);
            }
          },
          set: false
        });
        whenAvailable(`${node.props.id}`, (el) => {
          initEvents(node, el);
        });
      });
      node.on("child", ({ payload: childNode }) => {
        if (node.props.steps && node.props.steps.length) {
          node.props.steps = node.props.steps.filter((step2) => !step2.__isPlaceholder);
        }
        node.props.steps = Array.isArray(node.props.steps) && node.props.steps.length > 0 ? [...node.props.steps, childNode.context] : [childNode.context];
        node.props.steps = orderSteps(node.props.steps);
        setNodePositionProps(node.props.steps);
        childNode.props.stepName = childNode.props.label || camel2title(childNode.name);
        childNode.props.errorCount = 0;
        childNode.props.blockingCount = 0;
        childNode.props.isActiveStep = isFirstStep;
        isFirstStep = false;
        node.props.activeStep = node.props.activeStep ? node.props.activeStep : node.props.steps[0] ? node.props.steps[0].node.name : "";
      });
      node.on("prop:activeStep", ({ payload }) => {
        node.children.forEach((child) => {
          if (isPlaceholder(child))
            return;
          child.props.isActiveStep = child.name === payload;
          if (isBrowser && child.name === payload) {
            const el = document.querySelector(`[aria-controls="${child.props.id}"]`);
            if (el instanceof HTMLButtonElement) {
              el.focus();
            }
          }
        });
      });
      node.on("childRemoved", ({ payload: childNode }) => {
        let removedStepIndex = -1;
        childNode.props.ordered = false;
        node.props.steps = node.props.steps.filter((step2, index) => {
          if (step2.node.name !== childNode.name) {
            return true;
          }
          removedStepIndex = index;
          return false;
        });
        setNodePositionProps(node.props.steps);
        if (node.props.activeStep === childNode.name) {
          const targetIndex = removedStepIndex > 0 ? removedStepIndex - 1 : 0;
          node.props.activeStep = node.props.steps[targetIndex] ? node.props.steps[targetIndex].node.name : "";
        }
      });
    }
    if (node.props.type === "step" && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.props.type) === "multi-step") {
      let updateTotalErrorCount = function(node2) {
        node2.props.totalErrorCount = node2.props.errorCount + node2.props.blockingCount;
      };
      if (!node.context || !node.parent || !node.parent.context)
        return;
      node.addProps([
        "isActiveStep",
        "isFirstStep",
        "isLastStep",
        "stepName",
        "errorCount",
        "blockingCount",
        "totalErrorCount",
        "showStepErrors",
        "isValid",
        "hasBeenVisited",
        "ordered"
      ]);
      const parentNode = node.parent;
      node.on("created", () => {
        if (!node.context || !parentNode.context)
          return;
        whenAvailable(`${node.props.id}`, () => {
          parentNode.props.steps = orderSteps(parentNode.props.steps);
          setNodePositionProps(parentNode.props.steps);
        });
      });
      if (node.context && parentNode.context) {
        parentNode.context.handlers.setActiveStep = (stepNode) => setActiveStep.bind(null, stepNode);
        node.context.handlers.incrementStep = (delta, stepNode) => incrementStep.bind(null, delta, stepNode);
        node.context.makeActive = () => {
          setActiveStep(node.context);
        };
        node.context.handlers.next = () => incrementStep(1, node.context);
        node.context.handlers.previous = () => incrementStep(-1, node.context);
      }
      node.on("count:errors", ({ payload: count }) => {
        node.props.errorCount = count;
      });
      node.on("count:blocking", ({ payload: count }) => {
        node.props.blockingCount = count;
      });
      node.on("prop:errorCount", () => updateTotalErrorCount(node));
      node.on("prop:blockingCount", () => updateTotalErrorCount(node));
      node.on("prop:totalErrorCount", () => {
        node.props.isValid = node.props.totalErrorCount <= 0;
      });
      node.on("message-added", ({ payload }) => {
        if (payload.key === "submitted") {
          updateTotalErrorCount(node);
          if (node.context) {
            triggerStepValidations(node.context);
            node.props.showStepErrors = true;
          }
        }
      });
      node.on("prop:isActiveStep", () => {
        if (!node.props.hasBeenVisited && node.props.isActiveStep) {
          node.props.hasBeenVisited = true;
        }
      });
    } else if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.props.type) === "multi-step") {
      console.warn('Invalid FormKit input location. <FormKit type="multi-step"> should only have <FormKit type="step"> inputs as immediate children. Failure to wrap child inputs in <FormKit type="step"> can lead to undesired behaviors.');
    }
  };
  multiStepPlugin.library = (node) => {
    switch (node.props.type) {
      case "multi-step":
        return node.define(multiStep);
      case "step":
        const isInvalid = !node.parent || node.parent.props.type !== "multi-step";
        if (isInvalid) {
          console.warn('Invalid use of <FormKit type="step">. <FormKit type="step"> must be an immediate child of a <FormKit type="multi-step"> component.');
        }
        return node.define(step);
    }
  };
  return multiStepPlugin;
}
function createFloatingLabelsPlugin(FloatingLabelsOptions) {
  const floatingLabelsPlugin = (node) => {
    node.addProps(["floatingLabel"]);
    const useFloatingLabels = typeof node.props.floatingLabel === "boolean" ? node.props.floatingLabel : typeof (FloatingLabelsOptions === null || FloatingLabelsOptions === void 0 ? void 0 : FloatingLabelsOptions.useAsDefault) === "boolean" ? FloatingLabelsOptions === null || FloatingLabelsOptions === void 0 ? void 0 : FloatingLabelsOptions.useAsDefault : false;
    if (useFloatingLabels) {
      node.on("created", () => {
        if (!node.props || !node.props.definition)
          return;
        const inputDefinition = clone(node.props.definition);
        if (["text", "dropdown"].includes(node.props.family) || ["datepicker", "textarea"].includes(node.props.type)) {
          const originalSchema = inputDefinition.schema;
          if (typeof originalSchema !== "function")
            return;
          const higherOrderSchema = (extensions) => {
            extensions.outer = {
              attrs: {
                "data-floating-label": "true"
              }
            };
            extensions.label = {
              attrs: {
                "data-has-value": '$_value !== "" && $_value !== undefined'
              }
            };
            const inputSchema = originalSchema(extensions);
            const finalSchema = Array.isArray(inputSchema) ? inputSchema[0] : inputSchema;
            const [labelParentChildren, labelSection] = findSection(finalSchema, "label");
            const [inputParentChildren] = findSection(finalSchema, "input");
            if (labelParentChildren && labelSection && inputParentChildren) {
              labelParentChildren.splice(labelParentChildren.indexOf(labelSection), 1);
              inputParentChildren.push(labelSection);
            }
            return inputSchema;
          };
          inputDefinition.schema = higherOrderSchema;
          if (inputDefinition.schemaMemoKey) {
            inputDefinition.schemaMemoKey += "-floating-label";
          }
          node.props.definition = inputDefinition;
        }
      });
    }
  };
  return floatingLabelsPlugin;
}
function createLocalStoragePlugin(localStorageOptions) {
  const localStoragePlugin = (node) => {
    if (node.type !== "group")
      return;
    if (typeof window === "undefined")
      return;
    let cachedLocalStorageData = "";
    const shouldUseLocalStorage = (controlNode) => {
      let controlFieldValue = true;
      if (controlNode) {
        controlFieldValue = controlNode.value === true;
      }
      return undefine(node.props.useLocalStorage) && controlFieldValue;
    };
    node.on("created", async () => {
      var _a, _b, _c;
      await node.settled;
      node.addProps(["useLocalStorage"]);
      node.extend("restoreCache", {
        get: (node2) => async () => {
          if (!cachedLocalStorageData)
            return;
          await node2.settled;
          loadValue(cachedLocalStorageData);
        },
        set: false
      });
      const controlField = (_a = localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.control) !== null && _a !== void 0 ? _a : void 0;
      let controlNode;
      if (typeof controlField === "string") {
        const controlNode2 = node.at(controlField);
        if (controlNode2) {
          controlNode2.on("commit", () => {
            useLocalStorage = shouldUseLocalStorage(controlNode2);
            if (!useLocalStorage) {
              localStorage.removeItem(storageKey);
            }
          });
        }
      }
      let useLocalStorage = shouldUseLocalStorage(controlNode);
      let saveTimeout = 0;
      const debounce = typeof (localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.debounce) === "number" ? localStorageOptions.debounce : 200;
      const prefix = (_b = localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.prefix) !== null && _b !== void 0 ? _b : "formkit";
      const maxAge = (_c = localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.maxAge) !== null && _c !== void 0 ? _c : 36e5;
      const key = (localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.key) ? `-${localStorageOptions.key}` : "";
      const storageKey = `${prefix}${key}-${node.name}`;
      const loadValue = async (forceValue) => {
        const value = forceValue || localStorage.getItem(storageKey);
        if (!value)
          return;
        const loadValue2 = JSON.parse(value);
        if (typeof (localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.beforeLoad) === "function") {
          node.props.disabled = true;
          try {
            loadValue2.data = await localStorageOptions.beforeLoad(loadValue2.data);
          } catch (error) {
            console.error(error);
          }
          node.props.disabled = false;
        }
        if (!loadValue2 || typeof loadValue2.data !== "object")
          return;
        if (loadValue2.maxAge > Date.now()) {
          node.input(loadValue2.data, false);
        } else {
          localStorage.removeItem(storageKey);
        }
      };
      const saveValue = async (payload) => {
        let savePayload = payload;
        if (typeof (localStorageOptions === null || localStorageOptions === void 0 ? void 0 : localStorageOptions.beforeSave) === "function") {
          try {
            savePayload = await localStorageOptions.beforeSave(payload);
          } catch (error) {
            console.error(error);
          }
        }
        if (!savePayload)
          return;
        localStorage.setItem(storageKey, JSON.stringify({
          maxAge: Date.now() + maxAge,
          data: savePayload
        }));
      };
      node.on("commit", ({ payload }) => {
        if (!useLocalStorage)
          return;
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
          saveValue(payload);
        }, debounce);
      });
      node.on("prop:useLocalStorage", () => {
        useLocalStorage = shouldUseLocalStorage(controlNode);
        if (!useLocalStorage) {
          localStorage.removeItem(storageKey);
        }
      });
      node.hook.submit((payload, next) => {
        cachedLocalStorageData = localStorage.getItem(storageKey);
        localStorage.removeItem(storageKey);
        return next(payload);
      });
      await loadValue();
    });
  };
  return localStoragePlugin;
}
function createAutoHeightTextareaPlugin() {
  const autoHeightTextareaPlugin = (node) => {
    if (node.props.type !== "textarea")
      return;
    node.addProps(["autoHeight"]);
    node.on("created", () => {
      const autoHeight = undefine(node.props.autoHeight);
      if (!autoHeight || !node.context)
        return;
      let inputElement = null;
      whenAvailable(node.context.id, () => {
        var _a;
        inputElement = document.getElementById(((_a = node === null || node === void 0 ? void 0 : node.context) === null || _a === void 0 ? void 0 : _a.id) ? node.context.id : "");
        calculateHeight();
        node.on("input", () => {
          calculateHeight();
        });
        function calculateHeight() {
          if (!inputElement)
            return;
          let scrollHeight = inputElement.scrollHeight;
          inputElement === null || inputElement === void 0 ? void 0 : inputElement.setAttribute("style", `min-height: 0px`);
          scrollHeight = inputElement.scrollHeight;
          inputElement === null || inputElement === void 0 ? void 0 : inputElement.setAttribute("style", `min-height: ${scrollHeight}px`);
        }
      });
    });
  };
  return autoHeightTextareaPlugin;
}
export {
  createAutoAnimatePlugin,
  createAutoHeightTextareaPlugin,
  createFloatingLabelsPlugin,
  createLocalStoragePlugin,
  createMultiStepPlugin
};
//# sourceMappingURL=@formkit_addons.js.map
